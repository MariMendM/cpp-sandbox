//============================================================================
// Name        : ErrorHandling.cpp
// Author      : Mariane
// Version     :
// Copyright   : Your copyright notice
// Description : Knowledge of Error Handling
//============================================================================

#include <iostream>
#include <vector>
using namespace std;

int main() {

	//----------------------------------------------------------------------------------------------
	//ERROR CODES - WHY NOT?
	/*----------------------------------------------------------------------------------------------
	  - Functions with lots of return possibilities are hard to read/maintain
	  - Return error codes impede returns of useful things
	  - Handling these return error codes (switch) can generate (very) long codes
	  - When new conditions are inserted/changed into a function, all places where it is used have to
		be updated as well
	  - Reuse of functions can cause conflicts if the same values are used to different errors
	  - Do not work with class constructors which do not have return
	//--------------------------------------------------------------------------------------------*/



	//----------------------------------------------------------------------------------------------
	//EXCEPTIONS
	/*----------------------------------------------------------------------------------------------
	  - Thrown every time something goes wrong
	  - Automatically jumps to code that shall handle it
	  - An exception class instance is passed to the handler code with more info about error than
		just a code
	  - Compiler assumes responsibility assuring some error prone activities
	  - It causes tough some overhead
	
	Example of using exceptions vs do not use:
			vector<int> V1;
			cout << V1[2];	//no verification: program runs in undefined state (or terminates)
			cout << V1.at(2);	//error! but it takes more time than previous line
	
	The exception mechanism requires extra code generated by compiler. To indicate where to put it,
	codes that shall throw exceptions must be inside a 'try' block. The handler will be inside
	following 'catch' block:
	*/

		vector<int> V2;
		try {
			cout << V2.at(2);
		}
		//pass by reference to:
		//- use dynamic binding for any subclass exception passed (polymorphism);
		//- avoids overhead of copy constructors when passed by value
		//- avoids throw exceptions due to copy constructor when passed by value
		catch (const exception &e) {
			cout << "001. <const exception &e>:\n\t" << e.what() << endl;
		}

	//For custom exceptions, we use 'throw' in the code. Rewriting:

		size_t index = 2;
		try {
			if (index > V2.size())
				throw "Custom <out of range>!";
		}
		//pass argument of type raised in 'throw'
		catch (const char *e) {
			cout << "002. Custom <const char *e>:\n\t" << e << endl;
		}

	//Standard exceptions can also be raised using 'throw':
		int i = -1;
		try {
			if (i < 0)
				throw std::runtime_error("Negative not allowed!");
		}
		//pass argument of type raised in 'throw'
		catch (const runtime_error &e) {
			cout << "003. Standard <const runtime_error &e>:\n\t" << e.what() << endl;
		}

	//We can have as many catches as needed; remember to consider that they are checked in order
	//of appearance and the first one matching the exception will be executed:

		//Incorrect ordering:
		try {
			cout << V2.at(2);
		}
		catch (const exception &e) {
			cout << "004. Most General:\n\t" << e.what() << endl; //most general, gets everything!
		}
		catch (const out_of_range &e) {
			cout << "004. Least General:\n\t" << e.what() << endl;
		}
		
		//Correct ordering:
		try {
			cout << V2.at(2);
		}
		catch (const out_of_range &e) {
			cout << "005. Least General:\n\t" << e.what() << endl; //least general, shall come first
		}
		catch (const exception &e) {
			cout << "005. Most General:\n\t" << e.what() << endl;
		}

	/*For unexpected exceptions, the catch can be used with argument '...' that will bind to any type
	  of exceptions:
				try {}
				catch (const NetworkConnectionError &e) {}
				catch (const DataError &e) {}
				catch (const std::exception &e) {}
				catch (...) {}		//catches non-standard exceptions; we don not even know
									//the format of information here; it will probably just
									//log something like "unhandled exception"
	
	When the program is running a catch block, it may not be in stable state. Avoid:
	  - allocating memory or creating variables
	  - calling functions
	  - using types other than built-in ones
	Also, avoid code that could throw exceptions!

	If an exception is not handled by any catch blocks after try, the program will try to find one
	in the "enclosing scope" of the call stack, which is:
	  - an outer catch block if try-catch is nested in a try;
				try {  					//outer try
					try {...} 				//inner try
					catch () {...} 			//inner: no catches here...
				catch () {...} 			//outer: ... let's check here!
	  - a catch in the calling function, if try-catch is inside a function;
				void process_data() {
					try {
						get_file();
					} catch() { ... }	//...let's check here!
				}
				void get_file() {
					throw ...			//no catches here...
				}
	None find, it terminates.
	//--------------------------------------------------------------------------------------------*/



	//----------------------------------------------------------------------------------------------
	//EXCEPTION MECHANISM - WHAT HAPPENS?
	/*----------------------------------------------------------------------------------------------
	When exception is thrown:
	  - The thrown instance is copied in a special area of memory set up by compiler
	  - This area is accessible by any catch block
	  - Local variables of try block are destroyed, including original thrown instance
	  - The program leaves try block
	  - The program performs "stack unwinding", searching for catch block in the 'enclosing scope' as
		described in section before:
	  -- first, in the local scope of the function where exception was thrown; if none is found, it
		 exits the function destroying all variables
	  -- then it searches in the local scope of function's caller; if none is found, it exits...
	  -- this continues until it finds a suitable handler; if it exits main() without finding one, the
		 program calls std::terminate
	
	When a suitable handler is found, the program executes the code in it and proceeds to the next
	instruction after catch block executed. However, the handler can "re-throw" the exception to be
	handled again by outer catch blocks:
			catch(const TcpHandshakeFailure &e) {
				logfile << e.what() << endl;
				e.remote_host = remote_host;		//save name of the server
				throw NetWorkConnectionError(e);	//rethrows high-level exception; or
				throw e;						//rethrows a copy of original exception; or
				throw;							//rethrows original exception itself
			}
	
	During the stack unwinding process, destructors are frequently called during variable destruction.
	What happens if one of these destructors throws an exception? If it is not handled inside the
	destructor, a stack unwinding will ensue in parallel to the one already occurring, which can be
	disastrous. For that, destructors shall never throw exceptions, handling whatever problem they
	have inside it.
	
	Constructors, on the other hand, may not be able to handle their own issues assuring that instance
	will be actually created with no problems. They usually throw exceptions that shall be handled by
	the caller, but not letting problems behind once that, if it fails, the destructor is called and
	the result is simply an instance not created.
	//--------------------------------------------------------------------------------------------*/



	//----------------------------------------------------------------------------------------------
	//STD::EXCEPTION
	/*----------------------------------------------------------------------------------------------
	Hierarchy:
	  - BAD_ALLOC (when memo allocation fails)
	  - BAD_CAST (when dynamic cast fails)
	  - LOGIC_ERROR (parent class for conditions of faulty logic)
	  	-- out_of_range
	  	-- invalid_argument (ex: stoi() receiving a string not convertible to int)
	    -- domain_error (data outside domain of applicable values; ex: 30/FEV)
	    -- length_error (ex.: resize vector beyond max_size allowed)
	  - RUNTIME_ERROR (parent class for conditions beyond program's control)
	    -- overflow_error (result of computation too large for the variable type which stores it)
	    -- underflow_error (result of floating-point computation to small for the variable type)
	    -- range_error (result of computation cannot be represented by variable type whhich stores it)

	Member functions:
	  - constructor, copy constructor
	  - copy assignment operator
	  - virtual destructor
	  - virtual function what()
	//--------------------------------------------------------------------------------------------*/
	


	//----------------------------------------------------------------------------------------------
	//EXCEPTION SAFETY
	/*----------------------------------------------------------------------------------------------
	Safe x neutral:
	- Code is "exception safe" if it behaves correctly when exceptions are thrown
	- Code is "exception neutral" if it does not handle exceptions itself, but allows the caller to
	  handle it (constructors, for example)
	
	How to write exception-safe codes:
	- BASIC exception guarantee: if an exception is thrown, no resources are leaked (C++ standard
	  libraries conform to this method)
	- STRONG exception guarantee: if an exception is thrown, the program returns to previous state
	  (STL containers conform mostly to this method)
	- NO-THROW guarantee: when sub-operations do not throw exceptions in order to write code that
	  provides basic or strong guarantees around it; none of the built-in functions/operators in the
	  core C++ throw exceptions, except by new (BAD_ALLOC), dynamic_cast (BAD_CAST) and throw.
	
	When using not-throw guarantee, we can use 'noexception' to declare that a function will not
	raise anything:
				void function1 (int input) noexception {...}
				void function1 (int input) throw() {...}		//for older versions of C++
	This is useful for the caller, that knows that no exceptions need to be handled, and also for the
	compiler optimize code knowing that no extra exception code is necessary to be added.
	PS.: The programmer is the one who has to guarantee that no exception is thrown in the function;
	the compiler does not verify whether this is true or not.
	
	Discussing guarantees in classes a lit bit further:
	*/
		class BufferManager {
		private:
			int size;
			char *buffer;
		public:
			//CONSTRUCTOR: strong guarantee once no instances are created/modified in case of error;
			//the partially created instance, if new fails, will be destroyed completely
				BufferManager (int size) : size(size) { buffer = new char[size]; }

			//DESTRUCTOR: no-throw guarantee once 'delete' is noexception instruction
				~BufferManager () { delete [] buffer; }

			//COPY CONSTRUCTOR: strong guarantee once no instances are created/modified in case of
			//error; the partially created instance, if new fails, will be destroyed completely
				BufferManager (const BufferManager & other) {
					size = other.size;
					buffer = new char[size];
					for (int i=0; i<size; ++i)
						buffer[i] = other.buffer[i];
				}

			//COPY ASSIGNMENT OPERATOR V1: basic guarantee once that if new fails, it exits with a
			//buffer released (no memory leak), but that will cause undefined behavior when accessed
			//and destroyed; so the exit state is not the same of before operator be executed, thus
			//it does not provide strong guarantee
				BufferManager & operator = (const BufferManager & other) {
					if (this != & other) {
						delete [] buffer;			//noexception instruction - OK
						size = other.size;
						buffer = new char[size];	//throws error and returns: no Leaks, OK!
													//but buffer points to a memo area released: PROBLEM!
						for (int i=0; i<size; ++i)
							buffer[i] = other.buffer[i];
					}
					return *this;
				}

			//COPY ASSIGNMENT OPERATOR V2: strong guarantee once the original instance will be returned
			//unaltered in case of failure
			/*	BufferManager & operator = (const BufferManager & other) {
					BufferManager temp(other);	//copy constructor has strong guarantee; if it fails
												//swap won't execute and original instance is returned
					swap(*this, temp);
					return *this;
				}
			*/
		};
	//----------------------------------------------------------------------------------------------



	//----------------------------------------------------------------------------------------------
	//CUSTOM EXCEPTION CLASSES
	/*----------------------------------------------------------------------------------------------
	- Must have a constructor which takes a const string;
	- Must have copy constructor
	- Override the what() virtual function, if necessary
	- Add data members (built-in types only) necessary to store info relevant to this exception
	
	So, in one example:
	- create exception 'bad_grades' for grades negative or over 100%;
	- It represents an exception 'out_of_range', so the class will derive from this one; */

		class bad_grade : public std::out_of_range {
			public:
				//constructors
				bad_grade() : std::out_of_range("Invalid grade!") {}	//default
				bad_grade(const string &s) : std::out_of_range(s) {}	//for consistency with std::exception
				bad_grade(const char *s) : std::out_of_range(s) {}		//for consistency with std::exception

				//no additional data members, so no copy constructor needed (default one suffice)
				//no additional data members, so no destructor needed (default one suffice)

				const char* what() const noexcept { return std::out_of_range::what();}
		};

		class StudentGrade {
			private:
				int grade;
			public:
				StudentGrade(int grade) : grade(grade) {
					if (grade<0 || grade>100)
						throw bad_grade();
				}
		};

		try { StudentGrade SG1(-1); }
		catch(bad_grade &e) { cout << "006. StudentGrade:\n\t" << e.what() << endl; }
		try { StudentGrade SG3(110); }
		catch(bad_grade &e) { cout << "006. StudentGrade:\n\t" << e.what() << endl; }


		class StudentGradeV2 {
			private:
				int grade;
			public:
				StudentGradeV2(int grade) : grade(grade) {
					if (grade<0)
						throw bad_grade("Negative");
					if (grade>100)
						throw bad_grade("Higher than 100");
				}
		};

		try { StudentGradeV2 SG1v2(-1); }
		catch(bad_grade &e) { cout << "007. StudentGradeV2:\n\t" << e.what() << endl; }
		try { StudentGradeV2 SG3v2(110); }
		catch(bad_grade &e) { cout << "007. StudentGradeV2:\n\t" << e.what() << endl; }

	//----------------------------------------------------------------------------------------------




	cout << "END OF PROGRAM" << endl; // prints END OF PROGRAM
	return 0;
}
